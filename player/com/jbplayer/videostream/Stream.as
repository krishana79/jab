//// Copyright (c) 2009, the Open Video Player authors. All rights reserved.//// Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are // met:////    * Redistributions of source code must retain the above copyright //		notice, this list of conditions and the following disclaimer.//    * Redistributions in binary form must reproduce the above //		copyright notice, this list of conditions and the following //		disclaimer in the documentation and/or other materials provided //		with the distribution.//    * Neither the name of the openvideoplayer.org nor the names of its //		contributors may be used to endorse or promote products derived //		from this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//package com.jbplayer.videostream{		import flash.net.NetConnection;	import flash.display.MovieClip;	import flash.text.TextFormat;	import flash.media.Video;	import flash.events.*;		import org.openvideoplayer.net.*;	import org.openvideoplayer.events.*;	import com.model.PlayerData;		public class Stream extends MovieClip {		private var _nc:OvpConnection;		private var _ns:OvpNetStream;		private var _scrubberDragging:Boolean;		private var _playBtnStatePlaying:Boolean;		private var _url:String;		private var _waitForSeek:Boolean;		private var _streamLength:Number;		private var _filename:String;				private var _currentState:uint = 1;		private const _STATE_PDL_:uint = 1;		private const _STATE_STREAM_:uint = 2;				private var _stage:*;		private var progressMaxWidth:Number = 0;		private var totalDuration:Number =0;		private var _currentCuePointIndex:Number = 0;		private var streamend:Boolean = false;				// Constructor		public function Stream(par:*) {			_stage = par;			// Initialize private vars			_scrubberDragging = false;			_playBtnStatePlaying = false;			_waitForSeek = false;			_streamLength = 0;			_currentState = 0;			_currentCuePointIndex = 0;			//_currentCuePointText = "";						progressMaxWidth = 275//_stage.playerControl.seekBar.seekbg.width						_stage.playerControl.seekBar.progressBar.mouseChildren=false;						_stage.playerControl.seekBar.seekbg.addEventListener("click", onScrubberThumbRelease);	// Play button						_stage.playerControl._btnPlay.addEventListener("click", onClickBtnPlay);	// Play button			_stage.playerControl.audio.addEventListener("click", onClickBtnAudio);	// Play button						//_videoMC._scrubber.addEventListener("thumbPress", onScrubberThumbPress);			//_videoMC._scrubber.addEventListener("thumbRelease", onScrubberThumbRelease);						// Create the connection object and add the necessary event listeners			_nc = new OvpConnection()			_nc.addEventListener(OvpEvent.ERROR, errorHandler);			_nc.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler);			_nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);												// for http//			onClickBtnLoadPDL();			// for rtmp			onClickBtnLoadStreaming();		}				private function setStage():void{			//_stage.			//progressMaxWidth		}						/*private function showCuePoint(_show:Boolean=true):void {			_cuePointMC.visible = _show;			_cuePointMC._lblCuePoint.text = _currentCuePointText; 		}*/				private function showVideo(_show:Boolean=true):void {			//_videoMC.visible = _show;			//_cuePointMC.visible = _show;		}				// Starts the video playing when everything is ready   		private function playVideo(name:String):void {   			_playBtnStatePlaying = true;			//_videoMC._btnPlay.label = "pause";			_stage.playerControl._btnPlay.gotoAndStop(1);   			_ns.play(name);   			showVideo();   		}				// This method is called from the netStatusHandler below when we receive a good connection				private function connectedHandler():void {			//trace("Successfully connected to: " + _nc.netConnection.uri);			_stage.playerControl._btnPlay.enabled = true;			// Instantiate an OvpNetStream object			_ns = new OvpNetStream(_nc);						// Add the necessary listeners			_ns.addEventListener(NetStatusEvent.NET_STATUS, streamStatusHandler);			_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, streamPlayStatusHandler);			_ns.addEventListener(OvpEvent.NETSTREAM_METADATA, metadataHandler);			//_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, cuepointHandler);			_ns.addEventListener(OvpEvent.PROGRESS, update);			_ns.addEventListener(OvpEvent.STREAM_LENGTH, streamLengthHandler); 			// Tell the OvpNetStream object we want it to generate NetStream.Pause.Notify 			// for progressive download files because the Flash Player will not			_ns.createProgressivePauseEvents = true;						// Give the video object our net stream object			_stage._video.attachNetStream(_ns);						// Give the cue point manager the OvpNetStream object so it can start monitoring			//_cuePointMgr.netStream = _ns;						trace(_currentState , _STATE_PDL_)			if (_currentState == _STATE_PDL_) {				// Progressive download				//_videoMC._progressBar.setProgress(0, 100);				//_videoMC._progressBar.visible = true;					_filename = "http://video.asos-media.com/CatwalkShots/3067752-4-131114124934.flv"				playVideo(_filename);			} else {				// Streaming				//_videoMC._progressBar.visible = false;				/*trace("Port: " + _nc.actualPort);				trace("Protocol: " + _nc.actualProtocol);				trace("IP address: " + _nc.serverIPaddress);*/				// Start the asynchronous process of requesting the stream length				_nc.requestStreamLength(_filename);			}		}						private function toggleDragging(_state:Boolean):void {			_scrubberDragging = _state;			if (!_state) {				_waitForSeek = true;				doSeek();			}		}				private function doSeek() : void {			//showCuePoint(false);			_currentCuePointIndex = 0;			//_ns.seek(_videoMC._scrubber.value);		}				private function onClickBtnAudio(e:MouseEvent):void{			if(e.currentTarget.currentFrame == 1){				_ns.volume=0;				e.currentTarget.gotoAndStop(2);				dispatchEvent(new Event("AUDIO_OFF"));				trace("-- if")			}else{				_ns.volume=.8;				e.currentTarget.gotoAndStop(1);				dispatchEvent(new Event("AUDIO_ON"));				trace("-- else")			}		}		//-------------------------------------------------------------------		//		// Event Handlers		//		//-------------------------------------------------------------------		/*private function onScrubberThumbPress(event:SliderEvent):void {			toggleDragging(true);		}				private function onScrubberThumbRelease(event:SliderEvent):void {			toggleDragging(false);						var pos:uint = MovieClip(event.target.parent).mouseX;				ns.seek(pos*ns.duration/progressMaxWidth);		}*/				private function onScrubberThumbRelease(event:MouseEvent):void {			var pos:uint = MovieClip(event.target.parent).mouseX;			_ns.seek(pos*_streamLength/progressMaxWidth);		}				private function onClickBtnPlay(event:MouseEvent):void {			if (_playBtnStatePlaying) {				_ns.pause();				//_videoMC._btnPlay.label = "play";				_stage.playerControl._btnPlay.gotoAndStop(2);				dispatchEvent(new Event("PAUSE_STREAM"));			}			else {				if(!streamend){					_ns.resume();				}				else				{									if (_nc.isProgressive) 					{						playVideo(_filename);					}					else					{						_nc.requestStreamLength(_filename);					}					streamend = false;				}				_stage.playerControl._btnPlay.gotoAndStop(1);				dispatchEvent(new Event("PLAY_STREAM"));			}									_playBtnStatePlaying = !_playBtnStatePlaying;		}				private function onClickRbPDL(event:MouseEvent):void {			if (_currentState == _STATE_PDL_) {				return;			}						if (_ns) {				if (_playBtnStatePlaying) {					onClickBtnPlay(null);				}				if (_nc.isProgressive) {					showVideo(true);				}				else {					showVideo(false);				}			}						//_pdlMC.visible = true;			//_streamingMC.visible = false;			_currentState = _STATE_PDL_;		}				private function onClickRbStreaming(event:MouseEvent):void {			if (_currentState == _STATE_STREAM_) {				return;			}						if (_ns) {				if (_playBtnStatePlaying) {					onClickBtnPlay(null);				}				if (_nc.isProgressive) {					showVideo(false);				}				else {					showVideo(true);				}			}			//_streamingMC.visible = true;			//_pdlMC.visible = false;			_currentState = _STATE_STREAM_;		}				private function onClickBtnLoadPDL():void {			//showCuePoint(false);			showVideo(false);			_currentCuePointIndex = 0;			_currentState = _STATE_PDL_;			//_filename = _pdlMC._cbPdlUrl.text;						if (_nc.netConnection is NetConnection) {				_nc.close();			}						_nc.connect(null);		}				private function onClickBtnLoadStreaming():void {			/*_filename = "14808/nocc_small307K";//_streamingMC._cbStreamName.text;			var hostname:String = "cp27886.edgefcs.net/ondemand"*/			_filename = "mp4:"+PlayerData.videostream+".mp4"; //"mp4:sample_video.mp4"//			var hostname:String = PlayerData.HOST_NAME;//"s3iusclbqsgvt9.cloudfront.net/cfx/st/"						if (_nc.netConnection is NetConnection) {				_nc.close();			}			_currentState = _STATE_STREAM_;			_nc.connect(hostname);		}				// Handles all OvpEvent.ERROR events		private function errorHandler(e:OvpEvent):void {			trace("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR");		}				// Handles the stream length response after a call to requestStreamLength		private function streamLengthHandler(e:OvpEvent):void {			//trace("Stream length is " + e.data.streamLength);			//_videoMC._scrubber.maximum = e.data.streamLength;			//_videoMC._scrubber.enabled = true;						_streamLength = e.data.streamLength;			dispatchEvent(new Event("DURATION_RECIEVED"))			trace("_streamLength = e.data.streamLength; "+_streamLength)			if (_currentState == _STATE_STREAM_)				playVideo(_filename);		}				// Handles NetStatusEvent.NET_STATUS events fired by the OvpConnection class		private function netStatusHandler(e:NetStatusEvent):void {			trace(e.info.code);			switch (e.info.code) {				case "NetConnection.Connect.Rejected":					trace("Rejected by server. Reason is "+e.info.description);					break;				case "NetConnection.Connect.Success":					connectedHandler();					break;			}		}		// Receives all cuepoint events dispatched by the active NetStream object		// Note this is the same handler for both embedded and ActionScript cue points		/*private function cuepointHandler(e:OvpEvent):void {			if (e && e.data && e.data.name && e.data.time) {				showCuePoint(false);				_currentCuePointText = e.data.name + " at (" + e.data.time + ") secs";				showCuePoint();				for (var i:int = _currentCuePointIndex; i < _cuePointsReadOnlyArray.length; i++) {					if (_cuePointsReadOnlyArray[i].time == e.data.time) {						_currentCuePointIndex = i;						//_videoMC._dataGrid.selectedIndex = _currentCuePointIndex;						_videoMC._dataGrid.scrollToSelected();						break;					}				}							}		}				*/		// Handles the OvpEvent.PROGRESS event fired by the OvpNetStream class   		private function update(e:OvpEvent):void {   						//_videoMC._timeDisplay.text =  _ns.timeAsTimeCode + "|"+ _nc.streamLengthAsTimeCode(_streamLength);   			if (!_scrubberDragging && !_waitForSeek) {   				//_videoMC._scrubber.value = _ns.time;								_stage.playerControl.seekBar.progressBar.width = ((_ns.time /_streamLength)*progressMaxWidth);   			}   			if (_currentState == _STATE_PDL_) {   				//_videoMC._progressBar.setProgress(_ns.bytesLoaded, _ns.bytesTotal);   			}   		}				// Handles the NetStatusEvent.NET_STATUS events fired by the OvpNetStream class					private function streamStatusHandler(e:NetStatusEvent):void {			trace("streamStatusHandler() - event.info.code="+e.info.code);			switch(e.info.code) {				case "NetStream.Buffer.Full":					// _waitForSeek is used to stop the scrubber from updating					// while the stream transtions after a seek					_waitForSeek = false;					break;									case "NetStream.Play.Stop":				dispatchEvent(new Event("STREAM_END"));				streamend = true;				_playBtnStatePlaying = false;				_stage.playerControl._btnPlay.gotoAndStop(2);				break;			}		}		// Handles the OvpEvent.NETSTREAM_PLAYSTATUS events fired by the OvpNetStream class		private function streamPlayStatusHandler(e:OvpEvent):void {							//trace(e.data.code);		}					// Handles the OvpEvent.NETSTREAM_METADATA events fired by the OvpNetStream class			private function metadataHandler(e:OvpEvent):void {			for (var propName:String in e.data) {				//trace("metadata: "+propName+" = "+e.data[propName]);			}				}			}}